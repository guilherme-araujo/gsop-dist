#include <iostream>
#include <unistd.h>
#include <thread>
#include <future>
#include "utils/graphParser.h"
#include "simulation.h"

using namespace std;

void waitupdate(){
	usleep(10000);
}

string str_nbuild = "-v";
string nbuild = "20210502.001";

int main(int argc, char* argv[]){

	//Default simulation values
	int samples = 1;
	int cycles = 1000;
	double ephBonus = 0.04;
	double ephBonusB = -1;
	int threads = 1;
	double ephStartRatio = 0.6;
	double ephBuildingRatio = 0.3333;
	double ephReusingRatio = 0.3333;
	bool ephPopHistory = false;
	bool behaviorHistory = false;
	int ephTime = 30;
	bool ni = false;
	int sampleid = 0;
	bool bEph = 1;
	int behaviorTime = 30;
	double reuseBonusMultiplierA = 0.3;
	double reuseBonusMultiplierB = 0.9;
	double buildingBonusA = 0.99;
	double buildingBonusB = 0.93;
	double searchingBonusA = 1.0;
	double searchingBonusB = 1.0;
	double ephBirthGenerationChance = 0.0;
	bool printPartials = false;
	double cheaterChanceA = 0.0;
	double cheaterChanceB = 0.0;
	double deathRate = 1.04;
	bool aOnly = false;
	bool lockABEph = false;

	//Simulation values parsing from argv
	string arg_samples = "samples";
	string arg_cycles = "cycles";
	string arg_ephBonus = "ephBonus";
	string arg_ephBonusB = "ephBonusB";
	string arg_threads = "threads";
	string arg_ephStartRatio = "ephStartRatio";
	string arg_ephBuildingRatio = "ephBuildingRatio";
	string arg_ephReusingRatio = "ephReusingRatio";
	string arg_ephPopHistory = "ephPopHistory";
	string arg_behaviorHistory = "behaviorHistory";
	string arg_ephTime = "ephTime";
	string arg_ni = "ni";
	string arg_sampleid = "sampleId";
	string arg_bEph = "bEph";
	string arg_behaviorTime = "behaviorTime";
	string arg_reuseBonusMultiplierA = "rBMA";
	string arg_reuseBonusMultiplierB = "rBMB";
	string arg_buildingBonusA = "bBA";
	string arg_buildingBonusB = "bBB";
	string arg_searchingBonusA = "sBA";
	string arg_searchingBonusB = "sBB";
	string arg_ephBirthGenerationChance = "ephBirthGenChance";
	string arg_printPartials = "printPartials";
	string arg_cheaterChanceA = "cheaterA";
	string arg_cheaterChanceB = "cheaterB";
	string arg_deathRate = "deathRate";
	string arg_lockABEph = "lockABEph";
	string arg_aOnly = "aOnly";

	for(int i = 1; i < argc; i+=2){
		if(str_nbuild.compare(argv[i])==0){
			cout<<nbuild<<endl;
			return 0;
		}else if(arg_samples.compare(argv[i])==0){
			samples = stoi(argv[i+1]);
		}else if(arg_cycles.compare(argv[i])==0){
			cycles = stoi(argv[i+1]);
		}else if(arg_ephBonus.compare(argv[i])==0){
			ephBonus = stod(argv[i+1]);
		}else if(arg_ephBonusB.compare(argv[i])==0){
			ephBonusB = stod(argv[i+1]);
		}else if(arg_threads.compare(argv[i])==0){
			threads = stoi(argv[i+1]);
		}else if(arg_ephStartRatio.compare(argv[i])==0){
			ephStartRatio = stod(argv[i+1]);
		}else if(arg_ephBuildingRatio.compare(argv[i])==0){
			ephBuildingRatio = stod(argv[i+1]);
		}else if(arg_ephReusingRatio.compare(argv[i])==0){
			ephReusingRatio = stod(argv[i+1]);
		}else if(arg_ephPopHistory.compare(argv[i])==0){
			ephPopHistory = stoi(argv[i+1]);
		}else if(arg_ephTime.compare(argv[i])==0){
			ephTime = stoi(argv[i+1]);
		}else if(arg_ni.compare(argv[i])==0){
			ni = stoi(argv[i+1]);
		}else if (arg_sampleid.compare(argv[i])==0){
			sampleid = stoi(argv[i+1]);
		}else if(arg_bEph.compare(argv[i])==0){
			bEph = stoi(argv[i+1]);
		}else if (arg_behaviorTime.compare(argv[i])==0){
			behaviorTime = stoi(argv[i+1]);
		}else if (arg_reuseBonusMultiplierA.compare(argv[i])==0){
			reuseBonusMultiplierA = stod(argv[i+1]);
		}else if (arg_reuseBonusMultiplierB.compare(argv[i])==0){
			reuseBonusMultiplierB = stod(argv[i+1]);
		}else if (arg_buildingBonusA.compare(argv[i])==0){
			buildingBonusA = stod(argv[i+1]);
		}else if (arg_buildingBonusB.compare(argv[i])==0){
			buildingBonusB = stod(argv[i+1]);
		}else if (arg_searchingBonusA.compare(argv[i])==0){
			searchingBonusA = stod(argv[i+1]);
		}else if (arg_searchingBonusB.compare(argv[i])==0){
			searchingBonusB = stod(argv[i+1]);
		}else if (arg_ephBirthGenerationChance.compare(argv[i])==0){
			ephBirthGenerationChance = stod(argv[i+1]);
		}else if (arg_printPartials.compare(argv[i])==0){
			printPartials = stoi(argv[i+1]);
		}else if (arg_cheaterChanceA.compare(argv[i])==0){
			cheaterChanceA = stod(argv[i+1]);
		}else if (arg_cheaterChanceB.compare(argv[i])==0){
			cheaterChanceB = stod(argv[i+1]);
		}else if (arg_behaviorHistory.compare(argv[i])==0){
			behaviorHistory = stoi(argv[i+1]);
		}else if (arg_deathRate.compare(argv[i])==0){
			deathRate = stod(argv[i+1]);
		}else if (arg_lockABEph.compare(argv[i])==0){
			lockABEph = stoi(argv[i+1]);
		}else if (arg_aOnly.compare(argv[i])==0){
			aOnly = stoi(argv[i+1]);
		}else{
			cout<<"Wrong option "<<argv[i]<<endl;
		}

	}
	
	//Parse graph generated by python script or another source
	Parser p;
	GsopGraph *g = p.parse("graph.txt");
	
	if(ephBonusB==-1){
		ephBonusB = ephBonus;
	}
	
	SimulationData simulationData;

	simulationData.ephBonus = ephBonus;
	simulationData.ephBonusB = ephBonusB;
	simulationData.ephStartRatio = ephStartRatio;
	simulationData.ephBuildingRatio = ephBuildingRatio;
	simulationData.ephReusingRatio = ephReusingRatio;
	simulationData.ephBirthGenerationChance = ephBirthGenerationChance;
	simulationData.aOnly = aOnly;
	simulationData.neighborhoodInheritance = ni;
	simulationData.birthRate = deathRate;
	simulationData.deathRate = deathRate;
	simulationData.plotDensity = 100;
	simulationData.cycles = cycles;
	simulationData.initialPop = g->nodes.size();
	simulationData.ephTime = ephTime;
	simulationData.g = g;
	simulationData.ephPopHistory = ephPopHistory;
	simulationData.sampleid = sampleid;
	simulationData.bEph = bEph;
	simulationData.behaviorTime = behaviorTime;
	simulationData.reuseBonusMultiplierA = reuseBonusMultiplierA;
	simulationData.reuseBonusMultiplierB = reuseBonusMultiplierB;
	simulationData.buildingBonusA = buildingBonusA;
	simulationData.buildingBonusB = buildingBonusB;
	simulationData.searchingBonusA = searchingBonusA;
	simulationData.searchingBonusB = searchingBonusB;
	simulationData.printPartials = printPartials;
	simulationData.behaviorHistory = behaviorHistory;
	simulationData.cheaterChanceA = cheaterChanceA;
	simulationData.cheaterChanceB = cheaterChanceB;
	simulationData.lockABEph = lockABEph;

	//Launch simulation threads according to number of samples
	vector<thread> tl;
	tl.resize(threads);
	vector<bool> tb; //false as not running
	tb.resize(threads);

	int scount = 0;

	vector< future<bool> >fut;
	fut.resize(threads);

	while(true){
		int ti = 0;

		for(ti = 0; ti < threads; ti++){

			if(!tb[ti] && scount!=samples){
				simulationData.sampleid = scount++;

				fut[ti] = async(Simulation::simulationV8,simulationData, ti);

				tb[ti] = true;
				
			}

			if(tb[ti]==true){
				if(fut[ti].wait_for(chrono::seconds(0))==future_status::ready){
					fut[ti].get();
					tb[ti] = false;
				}

			}

		}
		if(scount==samples){
			bool allover = true;
			for(ti = 0; ti < threads; ti++){
				if(tb[ti]){
					allover = false;
					break;
				}
			}
			if(allover) break;
		}

		thread wait = thread(waitupdate);
		wait.join();

	}

    return 0;
}
